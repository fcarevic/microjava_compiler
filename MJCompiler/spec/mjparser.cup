

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected;
	
	Logger log = Logger.getLogger(getClass());
   
   public void ispisi_poruku(String message){
   	log.error(message);
   
   }
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}

init with {:
	errorDetected = false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal AND, BOOL, BREAK, CASE, CHAR, CLASS, COLON, COMMA, CONST, CONTINUE, DIV, DO; 
terminal DOT, ELSE, ENUM, EQUAL, EXTENDS, GE, GT, IDENT, IF, LBRACE, LCURVPAREN; 
terminal LE, LPAREN, LT, MINUS, MINUSMINUS, MUL, NEW, NOTSAME, NUMBER, OR, PLUS; 
terminal  PLUSPLUS, PRINT, PROG,QUESTION, RBRACE, RCURVPAREN, READ, REM, RETURN, SEMI, STRING, RPAREN, VOID, WHILE, SWITCH, SAME;

nonterminal Program, NoMethodDeclList, MethodDeclList; 
nonterminal NoMethodDecl, ConstDecl, VarDecl, ClassDecl;
nonterminal ConstInitList, ConstInit, Type;
nonterminal VarInitList, VarInit ;  
nonterminal ExtendsClause ;
nonterminal ClassDeclList , MethodDecl;
nonterminal ReturnType, FormalParamList, VarDeclList ;
nonterminal FormalParam ;
nonterminal Statement, StatementList, Expr, CaseList, Case, ReturnStatement, PrintNumConst, PrintExpr;
nonterminal DesignatorStatement, DesingatorOption, ActualParameterList, Assignop ;
nonterminal Condition , ConditionTerm, ConditonFact, ConditionFactRelOp, Relop;
nonterminal Term , Factor, TermOptions ;
nonterminal Matched, Unmatched;
nonterminal MinusExpr, ProgName;
nonterminal ConstDeclList, StdConstType, Designator , AddopTermExprOption,  Addop, Mulop;
nonterminal DesignatorOptionList, DesignatorOption, AddopList;
precedence left ELSE;
start with Program;
Program ::= (Program) PROG ProgName NoMethodDeclList LCURVPAREN MethodDeclList RCURVPAREN
				{:
				parser.ispisi_poruku("ovde");
				
				:}
				;
ProgName ::= (ProgName) IDENT:progName;
NoMethodDeclList ::= (NoMethodDeclList_) NoMethodDeclList NoMethodDecl
					|
					(NoMethodDeclEmptyList) /*epsilon*/
					;
NoMethodDecl ::= (ConstDeclNoMethodDecl) ConstDecl 
				 |
				 (VarDeclNoMethodDecl) VarDecl
				 |
				 (ClassDeclNoMethodDecl) ClassDecl 
				 ;

ConstDeclList ::= (ConstDeclList) ConstDeclList ConstDecl;

ConstDecl ::= (ConstDecl) CONST Type ConstInitList SEMI ;
ConstInitList ::= (ConstInitMultipleList) ConstInitList COMMA ConstInit
					|
				(ConstInitSingle) ConstInit
					;
ConstInit ::= (ConstInit) IDENT EQUAL StdConstType ;

StdConstType ::= (StdConstBool) BOOL
				|
				(StdConstNumber) NUMBER
				|
				(StdConstString) STRING
				|
				(StdConstChar) CHAR
				;
					

VarDeclList ::= (VarDeclList_) VarDeclList VarDecl
				|
				(VarDeclEmptyList) /* epsilon*/
				;
				
VarDecl ::= (VarDecl) Type:varType VarInitList SEMI 
		 	;
VarInitList ::= (VarInitMultipleList) VarInitList COMMA VarInit
				|
				(VarInitSingle) VarInit:var
		 	;
				
VarInit ::= (VarInitPrimitive) IDENT:name
		   |
		   (VarInitArray) IDENT:name  LBRACE RBRACE 
		   ;

ClassDeclList ::= (ClassDeclList) ClassDeclList ClassDecl; 
					
ClassDecl ::= (ClassDeclsNoMethod) CLASS IDENT ExtendsClause LCURVPAREN VarDeclList RCURVPAREN 
				|
			(ClassDeclMethod) CLASS IDENT ExtendsClause LCURVPAREN VarDeclList LCURVPAREN MethodDeclList RCURVPAREN RCURVPAREN 
			;
ExtendsClause ::= (ExtendsClause_) EXTENDS Type 
				|
				(NoExtendsClause) /*epsilon*/
				;
				

MethodDeclList ::= (MethodDeclMultipleList) MethodDeclList MethodDecl
					|
					(MethodDeclEmptyList) /*epsilon*/
					; 
MethodDecl ::= (MethodDecl) ReturnType IDENT LPAREN FormalParamList RPAREN VarDeclList LCURVPAREN StatementList RCURVPAREN ;

ReturnType ::= (ReturnTypeType) Type 
				|
				(ReturnTypeVoid) VOID
				;

FormalParamList ::= (FormalParamList_) FormalParamList COMMA FormalParam
				|
				(FormalParamSingle) FormalParam
				|
				(FormalParamEmptyList) /*epsilon*/				
				;
FormalParam ::= (FormalParamPrimitive) Type IDENT
				|
				(FormalParamArray) Type IDENT LBRACE RBRACE
				;

Type ::= (Type) IDENT:typeName ;


StatementList ::= (StatementList_) StatementList Statement
				|
				(StatementEmptyList) /*epsilon*/
				;


 
Statement   ::= (DesignatorStatementStatement) DesignatorStatement  
			|
			(DoWhileStatement) DO Statement WHILE LPAREN Condition RPAREN SEMI
			|
			(SwitchStatement) SWITCH LPAREN  Expr RPAREN LCURVPAREN CaseList RCURVPAREN 
		    |
		    (BreakStatement) BREAK SEMI
		    |
		    (ContinueStatement) CONTINUE SEMI
		    |
		    (ReturnStatement_) ReturnStatement SEMI
		    |
		    (ReadStatement) READ LPAREN Designator RPAREN SEMI
		    |
		    (PrintStatement) PRINT LPAREN PrintExpr RPAREN SEMI
		    |
		    (StatementStatement) LCURVPAREN StatementList RCURVPAREN
		    |
		    (IfStatement) IF LPAREN Condition RPAREN Statement 
		    |
		    (IfElseStatement) IF  LPAREN Condition RPAREN Statement ELSE Statement
		    ;
		    
		    
		    
		    
CaseList ::= (CaseList_) CaseList Case
			 |
			 (CaseSingle) Case 
			 ;
Case  ::= (Case) CASE NUMBER COLON StatementList ; /*DA LI IDE STATEMENT ILI STATEMENTLIST*/

ReturnStatement ::= (ReturnStatementNoExpr) RETURN
					|
					(ReturnStatementExpr) RETURN Expr
					;
PrintExpr ::= (PrintExpr) Expr PrintNumConst ;
PrintNumConst ::= (PrintNumConst_)   COMMA NUMBER
					| 
					(NoPrintNumConst) /*epsilon*/
					; 

DesignatorStatement ::= (DesignatorStatement_) Designator DesingatorOption SEMI
						|
						(ErrorDesignator) error COMMA:l
		    {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null);  :}
		
						;
DesingatorOption ::= (AssignopExpr) Assignop Expr
					|
					LPAREN ActualParameterList RPAREN
					|
					(IncDesignator) PLUSPLUS
					|
					(DecDesignator) MINUSMINUS
					;



ActualParameterList ::= (ActualParameterMultipleList)  ActualParameterList COMMA Expr
					|
					(ActualParameterSingle) Expr
					|
					(ActualParameterEmptyList) /*epsilon*/
					;
Condition ::= (ConditionOR)Condition OR ConditionTerm
			|
			(NoConditionOR) ConditionTerm
			;
ConditionTerm ::= (ConditionAND) ConditionTerm AND ConditonFact
				|
				(NoConditionAND) ConditonFact
				;
ConditonFact ::= (ConditionFactExpr) Expr  
				|
				(ConditionFactExprRelop) Expr Relop Expr
				;

/* ****************************************** */
		    
Expr ::= (ExprTermMinus) MINUS  Term AddopList
			|
		(ExprTermNoMinus) Term AddopList
			;
		/*	
		(ConditionTernary) Condition QUESTION Expr COLON Expr
			;
		  |
		 (ConditionTernary) Condition QUESTION Expr COLON Expr
			 
			
		; */
AddopList ::= (AddopMultipleList) AddopList AddopTermExprOption
				|
				(AddopEmptyList) /*epsilon*/
				; 

AddopTermExprOption ::= (AddopTermExprOption_) Addop Term ;
						 	

Term ::= (TermNoMul) Factor 
		|
		(TermMul) Term Mulop Factor
		 ;

		    
	
		    
Factor ::= (FactorDesignatorActParams) Designator LPAREN ActualParameterList RPAREN
			|
			(FactorDesignator) Designator
			|
			(FactorNumber) NUMBER
						| 
			(FactorString) STRING
			|
			(FactorChar) CHAR
			|
			(FactorBool) BOOL
			|
			(FactorNew) NEW Type
			|
			(FactorNewExpr) NEW Type LBRACE Expr RBRACE
			|
			(FactorExpr) LPAREN Expr RPAREN
			;



Designator ::= (Designator) IDENT DesignatorOptionList ;
DesignatorOptionList ::= (DesignatorOptionList_) DesignatorOptionList DesignatorOption 
						|
						(DesignatorOptionEmptyList) /*epsilon*/
						;
DesignatorOption ::= (DesignatorDotIdentOption) DOT IDENT
					|
					(DesignatorIndexingOption) LBRACE Expr RBRACE
					;








Assignop ::= (Equal) EQUAL ;
Relop ::= (Same) SAME
		 |
		 (NotSame) NOTSAME
		 |
		 (GreaterThen) GT
		 |
		 (GreaterEqual) GE
		 |
		 (LessThen) LT
		 |
		 (LessEqual) LE
		 ;
		 
Addop ::= (Plus) PLUS
			|
			(Minus) MINUS
			;
Mulop ::= 	(Mul) MUL
			|
			(Div) DIV
			|
			(Rem) REM
			;

			
